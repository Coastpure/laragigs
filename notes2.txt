CLOCKWORK PACKAGE 

download chrome clockwork extenstion
run, composer require itsgoingd/clockwork

when you open clockwork extenstion it shows GET / ListingController@index 4ms
i.e get request controller method time

check on database tab it will show
Listing	
Listing	
SELECT * FROM `listings` ORDER BY `created_at` DESC

if you click on laravel on web page, database section of extension will show 
SELECT * FROM `listings` WHERE `tags` like '%laravel%' ORDER BY `created_at` DESC

CREATE LISTING FORM

we'll create a new route, a new controller method and a new view
on route, add 
Route::get('/listings/create', [ListingController::class, 'create']); 

on controller, add 
  public function create() {
        return view('listings.create');
    }

create a new file in views, listings  name it create.blade.php
in the post job button in footer, put the href to be 
href="/listings/create"   i.e the same directory in the route  Route::get('/listings/create')

make sure Route::get('/listings/{listing}', [ListingController::class, 'show']); is below the create one
because when you click on create it will look at the one that is above

go to create.html to paste the form code
paste the selected code 

you have to wrap it in the layouts component for the styles to show which are defined in the layout.blade file
i.e <x-layout> <x/layout>

remove the card div which we already have at card.blade
then wrap x-card /x-card around it too, to display it

read on max width tailwind i.e max-w-lg, it's what makes that card thin and into


VALIDATION AND STORE LISTING 

we now want to store new listings
make sure every field has a name i.e in create.blade, because thats how we can access the data in the form
we want the form to submit to listings i.e <form action="/listings">
but we want it to be a post request, so add POST, <form method="POST" action="/listings">

we have a directive in laravel @csrf, it prevents cross site scripting attacks, add it below

lets go to routes and create our store route
this time its going to be a post request
Route::post('/listings', [ListingController::class, 'store']);
so we are submitting the form to /listings route 
and its going to call the store method which we will now create

  public function store() {}

  add dd to check like last time 
  public function store(Request $request) {
        dd($request->all()); }
  if you click create gig website will show form created, remove the dd after checking

  For validation -checks if the information provided by a user is correct
  $formFields = $request->validate([
        'title' => 'required',    this part is to set rules we want 
 As you can see, the validation rules are passed into the validate method

 $formFields = $request->validate([    //we can use any name we want in place of $formfields
        'title' => 'required',
        'company' => ['required', Rule::unique('listings', 'company')], //make company name unique
        'location' => 'required',
        'website' => 'required',
        'email' => ['required', 'email'],  //has to be formatted as an email
        'tags' => 'required',
        'description' => 'required',
       ]);

under the rules add 
 return redirect('/');

to show the user an error when validation fails we can use @error directive 
in the views, under each form field, add an error message
@error('company')       //has to coincide with the name="company"
    <div class="alert alert-danger">{{ $message }}</div>
@enderror

add it under every input box
when a user fails the validation, it will generate an automatic error message 
The company field is required.

To have the form created in the database, in the controller;
we take our model and use create, we pass in $formfields which will contain our data
Listing::create($formFields);
when you input data and click submit it will show an error: 
Add [title] to fillable property to allow mass assignment on [App\Models\Listing].


MASS ASSIGNMENT

in order to put add fields in a database they have to be put in a fillable property in a model

Method 1
go to the model file and add the fillable property i.e listing.php
under hasFactory add protected $fillable = ,
we want to set it to an array and allow any properties which we wanna do mass asignment to
so we add them  protected $fillable = ['title', 'company', 'location', 'website', 'email', 'description', 'tags'];
now reload, you will see what you have input on the homepage

Method 2
search for AppServiceProvider file  i.e by using ctrl + p
in the boot funtion, add Model::unguard();
public function boot()
    {
        Model::unguard();
    }
by this we are allowing the mass assignment and we no longer need to require us to add the fillable
i.e protected $fillable = ['title', 'company', 'location', 'website', 'email', 'description', 'tags'];
if you add another listing it will still work
if you are going to use this method make sure you are aware of what's going into the database
and you have it set up correcly e.g  Listing::create($request->all()); instead of  Listing::create($formFields);




FLASH MESSAGE

show message when new listing is created

on return redirect('/'); add with i.e  return redirect('/')->with('message', 'Listing created succesfully!');
//the name message can be anything you want eg alert, error, success etc

we now need in our view to show the message, we make it a component and create flash-message.blade.php
check for the message we use if 
@if(session()->has('message')), that message word has to be similar as one put in LIstingController

then style it 
@if(session()->has('message'))
    <div class="fixed top-0 left-1/2 transform -translate-x-1/2 bg-laravel text-white px-48 py-3">
        <p>
            {{session('message')}} //this displays the message
        </p>

    </div>
@endif

we then need to put it in the layout, add <x-flash-message />
doesnt matter where we place it because position is fixed
when you create a listing it will show there until you reload, to remove it we can use alpine js
open https://alpinejs.dev/, copy the src, <script src="//unpkg.com/alpinejs" defer></script>
paste it to our layout page

to the flash message div, add x-data="{show: true}"
then we want it to show for a certain amount of time the dissapear, theres an attribute called x-init
basically when it initializes we want to run set timeout x-init="setTimeout(() => show = false)
we have made an arrow function, but we dont pass anything in there, then it takes in a second parameter
which is the number of milliseconds we want it to show so we add 3000 after false
then we add an x-show make it equal or set it to the show value i.e x-show="show"

after 3 seconds that show will turn into false and since we have x-show equal to that value, the message will dissapear
aftercreating a listing, it will show for 3 seconds then dissapear

2:36:32